// Code generated by sqlc. DO NOT EDIT.

import type  { Sql } from "postgres";

export const geoBoundariesFindCoordsQuery = `-- name: GeoBoundariesFindCoords :many
select id, name, polygon, level, updated_at from geo_boundaries
where postgis.st_within(postgis.st_point($1, $2), geo_boundaries.polygon)`;

export interface GeoBoundariesFindCoordsArgs {
    lon: string;
    lat: string;
}

export interface GeoBoundariesFindCoordsRow {
    id: string;
    name: string;
    polygon: string;
    level: number;
    updatedAt: Date;
}

export async function geoBoundariesFindCoords(sql: Sql, args: GeoBoundariesFindCoordsArgs): Promise<GeoBoundariesFindCoordsRow[]> {
    return (await sql.unsafe(geoBoundariesFindCoordsQuery, [args.lon, args.lat]).values()).map(row => ({
        id: row[0],
        name: row[1],
        polygon: row[2],
        level: row[3],
        updatedAt: row[4]
    }));
}

export const routeGetQuery = `-- name: RouteGet :one
with points_array as (
	select 
		id, 
		array_agg(array[postgis.st_y(p.geom), postgis.st_x(p.geom)] order by p.path) as lat_lon_array
	from routes r, postgis.st_dumppoints(r.linestring) p
	where r.id = $1
	group by r.id
) 
select 
  r.id, r.user_id, r.created_at, r.plan_id, r.name, r.linestring, r.stats_len_m, r.stats_score, r.stats_junction_count, r.is_deleted, r.map_preview_light, r.map_preview_dark,
	pa.lat_lon_array
from routes r
inner join points_array pa
	on pa.id = r.id
where r.id = $1
order by 
	r.created_at desc`;

export interface RouteGetArgs {
    id: string;
}

export interface RouteGetRow {
    id: string;
    userId: string;
    createdAt: Date;
    planId: string;
    name: string;
    linestring: string | null;
    statsLenM: string;
    statsScore: string;
    statsJunctionCount: string;
    isDeleted: boolean;
    mapPreviewLight: string | null;
    mapPreviewDark: string | null;
    latLonArray: string[];
}

export async function routeGet(sql: Sql, args: RouteGetArgs): Promise<RouteGetRow | null> {
    const rows = await sql.unsafe(routeGetQuery, [args.id]).values();
    if (rows.length !== 1) {
        return null;
    }
    const row = rows[0];
    if (!row) {
        return null;
    }
    return {
        id: row[0],
        userId: row[1],
        createdAt: row[2],
        planId: row[3],
        name: row[4],
        linestring: row[5],
        statsLenM: row[6],
        statsScore: row[7],
        statsJunctionCount: row[8],
        isDeleted: row[9],
        mapPreviewLight: row[10],
        mapPreviewDark: row[11],
        latLonArray: row[12]
    };
}

export const routeUpdateMapPreviewQuery = `-- name: RouteUpdateMapPreview :exec
update routes
set map_preview_dark = $1,
  map_preview_light = $2
where id = $3`;

export interface RouteUpdateMapPreviewArgs {
    mapPreviewDark: string | null;
    mapPreviewLight: string | null;
    id: string;
}

export async function routeUpdateMapPreview(sql: Sql, args: RouteUpdateMapPreviewArgs): Promise<void> {
    await sql.unsafe(routeUpdateMapPreviewQuery, [args.mapPreviewDark, args.mapPreviewLight, args.id]);
}

export const planUpdateMapPreviewQuery = `-- name: PlanUpdateMapPreview :exec
update plans
set map_preview_dark = $1,
  map_preview_light = $2
where id = $3`;

export interface PlanUpdateMapPreviewArgs {
    mapPreviewDark: string | null;
    mapPreviewLight: string | null;
    id: string;
}

export async function planUpdateMapPreview(sql: Sql, args: PlanUpdateMapPreviewArgs): Promise<void> {
    await sql.unsafe(planUpdateMapPreviewQuery, [args.mapPreviewDark, args.mapPreviewLight, args.id]);
}

export const userClaimPlansQuery = `-- name: UserClaimPlans :exec
update plans
set user_id = $1
where user_id = $2`;

export interface UserClaimPlansArgs {
    toUserId: string;
    fromUserId: string;
}

export async function userClaimPlans(sql: Sql, args: UserClaimPlansArgs): Promise<void> {
    await sql.unsafe(userClaimPlansQuery, [args.toUserId, args.fromUserId]);
}

export const userClaimRoutesQuery = `-- name: UserClaimRoutes :exec
update routes
set user_id = $1
where user_id = $2`;

export interface UserClaimRoutesArgs {
    toUserId: string;
    fromUserId: string;
}

export async function userClaimRoutes(sql: Sql, args: UserClaimRoutesArgs): Promise<void> {
    await sql.unsafe(userClaimRoutesQuery, [args.toUserId, args.fromUserId]);
}

export const userClaimRouteBreakdownStatsQuery = `-- name: UserClaimRouteBreakdownStats :exec
update route_breakdown_stats
set user_id = $1
where user_id = $2`;

export interface UserClaimRouteBreakdownStatsArgs {
    toUserId: string;
    fromUserId: string;
}

export async function userClaimRouteBreakdownStats(sql: Sql, args: UserClaimRouteBreakdownStatsArgs): Promise<void> {
    await sql.unsafe(userClaimRouteBreakdownStatsQuery, [args.toUserId, args.fromUserId]);
}

export const userClaimRuleSetsQuery = `-- name: UserClaimRuleSets :exec
update rule_sets
set user_id = $1
where user_id = $2`;

export interface UserClaimRuleSetsArgs {
    toUserId: string | null;
    fromUserId: string | null;
}

export async function userClaimRuleSets(sql: Sql, args: UserClaimRuleSetsArgs): Promise<void> {
    await sql.unsafe(userClaimRuleSetsQuery, [args.toUserId, args.fromUserId]);
}

export const userClaimRuleSetRoadTagsQuery = `-- name: UserClaimRuleSetRoadTags :exec
update rule_set_road_tags
set user_id = $1
where user_id = $2`;

export interface UserClaimRuleSetRoadTagsArgs {
    toUserId: string | null;
    fromUserId: string | null;
}

export async function userClaimRuleSetRoadTags(sql: Sql, args: UserClaimRuleSetRoadTagsArgs): Promise<void> {
    await sql.unsafe(userClaimRuleSetRoadTagsQuery, [args.toUserId, args.fromUserId]);
}

export const privateCodeGetQuery = `-- name: PrivateCodeGet :one
select id, code, created_at, claimed_at, claimed_by_user_id from private.codes
where code = $1`;

export interface PrivateCodeGetArgs {
    code: string;
}

export interface PrivateCodeGetRow {
    id: string;
    code: string;
    createdAt: Date;
    claimedAt: Date | null;
    claimedByUserId: string | null;
}

export async function privateCodeGet(sql: Sql, args: PrivateCodeGetArgs): Promise<PrivateCodeGetRow | null> {
    const rows = await sql.unsafe(privateCodeGetQuery, [args.code]).values();
    if (rows.length !== 1) {
        return null;
    }
    const row = rows[0];
    if (!row) {
        return null;
    }
    return {
        id: row[0],
        code: row[1],
        createdAt: row[2],
        claimedAt: row[3],
        claimedByUserId: row[4]
    };
}

export const privateCodeClaimQuery = `-- name: PrivateCodeClaim :exec
update private.codes
set claimed_at = now(), 
    claimed_by_user_id = $1
where code = $2`;

export interface PrivateCodeClaimArgs {
    claimedByUserId: string | null;
    code: string;
}

export async function privateCodeClaim(sql: Sql, args: PrivateCodeClaimArgs): Promise<void> {
    await sql.unsafe(privateCodeClaimQuery, [args.claimedByUserId, args.code]);
}

export const privateUserInsertQuery = `-- name: PrivateUserInsert :one
insert into private.users (user_id)
values ($1)
returning user_id, stripe_flow_status, stripe_customer_id, stripe_status, stripe_checkout_id, stripe_subscription_id, stripe_price_id, stripe_current_period_end, stripe_current_period_start, stripe_cancel_at_period_end, stripe_payment_method, sub_type`;

export interface PrivateUserInsertArgs {
    userId: string;
}

export interface PrivateUserInsertRow {
    userId: string;
    stripeFlowStatus: "none" | "initiated" | "completed" | "confirmed";
    stripeCustomerId: string | null;
    stripeStatus: string | null;
    stripeCheckoutId: string | null;
    stripeSubscriptionId: string | null;
    stripePriceId: string | null;
    stripeCurrentPeriodEnd: Date | null;
    stripeCurrentPeriodStart: Date | null;
    stripeCancelAtPeriodEnd: boolean | null;
    stripePaymentMethod: string | null;
    subType: "none" | "stripe" | "code";
}

export async function privateUserInsert(sql: Sql, args: PrivateUserInsertArgs): Promise<PrivateUserInsertRow | null> {
    const rows = await sql.unsafe(privateUserInsertQuery, [args.userId]).values();
    if (rows.length !== 1) {
        return null;
    }
    const row = rows[0];
    if (!row) {
        return null;
    }
    return {
        userId: row[0],
        stripeFlowStatus: row[1],
        stripeCustomerId: row[2],
        stripeStatus: row[3],
        stripeCheckoutId: row[4],
        stripeSubscriptionId: row[5],
        stripePriceId: row[6],
        stripeCurrentPeriodEnd: row[7],
        stripeCurrentPeriodStart: row[8],
        stripeCancelAtPeriodEnd: row[9],
        stripePaymentMethod: row[10],
        subType: row[11]
    };
}

export const privateUsersUpdateWithSubscriptionCodeQuery = `-- name: PrivateUsersUpdateWithSubscriptionCode :exec
update private.users 
set sub_type = $1
where user_id = $2
returning user_id, stripe_flow_status, stripe_customer_id, stripe_status, stripe_checkout_id, stripe_subscription_id, stripe_price_id, stripe_current_period_end, stripe_current_period_start, stripe_cancel_at_period_end, stripe_payment_method, sub_type`;

export interface PrivateUsersUpdateWithSubscriptionCodeArgs {
    subType: string;
    userId: string;
}

export interface PrivateUsersUpdateWithSubscriptionCodeRow {
    userId: string;
    stripeFlowStatus: "none" | "initiated" | "completed" | "confirmed";
    stripeCustomerId: string | null;
    stripeStatus: string | null;
    stripeCheckoutId: string | null;
    stripeSubscriptionId: string | null;
    stripePriceId: string | null;
    stripeCurrentPeriodEnd: Date | null;
    stripeCurrentPeriodStart: Date | null;
    stripeCancelAtPeriodEnd: boolean | null;
    stripePaymentMethod: string | null;
    subType: "none" | "stripe" | "code";
}

export async function privateUsersUpdateWithSubscriptionCode(sql: Sql, args: PrivateUsersUpdateWithSubscriptionCodeArgs): Promise<void> {
    await sql.unsafe(privateUsersUpdateWithSubscriptionCodeQuery, [args.subType, args.userId]);
}

export const privateUsersUpdateStripeCustomerIdQuery = `-- name: PrivateUsersUpdateStripeCustomerId :exec
update private.users
set stripe_customer_id = $1
where user_id = $2`;

export interface PrivateUsersUpdateStripeCustomerIdArgs {
    stripeCustomerId: string | null;
    userId: string;
}

export async function privateUsersUpdateStripeCustomerId(sql: Sql, args: PrivateUsersUpdateStripeCustomerIdArgs): Promise<void> {
    await sql.unsafe(privateUsersUpdateStripeCustomerIdQuery, [args.stripeCustomerId, args.userId]);
}

export const privateUsersUpdateSubTypeQuery = `-- name: PrivateUsersUpdateSubType :exec
update private.users
set sub_type = $1
where user_id = $2`;

export interface PrivateUsersUpdateSubTypeArgs {
    subType: string;
    userId: string;
}

export async function privateUsersUpdateSubType(sql: Sql, args: PrivateUsersUpdateSubTypeArgs): Promise<void> {
    await sql.unsafe(privateUsersUpdateSubTypeQuery, [args.subType, args.userId]);
}

export const privateUsersUpdateStripeDataQuery = `-- name: PrivateUsersUpdateStripeData :exec
update private.users
set stripe_status = $1,
  stripe_subscription_id = $3,
  stripe_price_id = $4,
  stripe_current_period_end = $5,
  stripe_current_period_start = $6,
  stripe_cancel_at_period_end = $7,
  stripe_payment_method = $8,
  stripe_flow_status = 'confirmed',
  sub_type = $9
where user_id = $2`;

export interface PrivateUsersUpdateStripeDataArgs {
    stripeStatus: string | null;
    userId: string;
    stripeSubscriptionId: string | null;
    stripePriceId: string | null;
    stripeCurrentPeriodEnd: Date | null;
    stripeCurrentPeriodStart: Date | null;
    stripeCancelAtPeriodEnd: string | null;
    stripePaymentMethod: string | null;
    subType: string;
}

export async function privateUsersUpdateStripeData(sql: Sql, args: PrivateUsersUpdateStripeDataArgs): Promise<void> {
    await sql.unsafe(privateUsersUpdateStripeDataQuery, [args.stripeStatus, args.userId, args.stripeSubscriptionId, args.stripePriceId, args.stripeCurrentPeriodEnd, args.stripeCurrentPeriodStart, args.stripeCancelAtPeriodEnd, args.stripePaymentMethod, args.subType]);
}

export const privateUsersUpdateInitiatedQuery = `-- name: PrivateUsersUpdateInitiated :exec
update private.users
set stripe_status = 'initiated',
  stripe_checkout_id = $1
where user_id = $2`;

export interface PrivateUsersUpdateInitiatedArgs {
    stripeCheckoutId: string | null;
    userId: string;
}

export async function privateUsersUpdateInitiated(sql: Sql, args: PrivateUsersUpdateInitiatedArgs): Promise<void> {
    await sql.unsafe(privateUsersUpdateInitiatedQuery, [args.stripeCheckoutId, args.userId]);
}

export const privateUsersUpdateCompletedQuery = `-- name: PrivateUsersUpdateCompleted :exec
update private.users
set stripe_flow_status = 'completed'
where user_id = $1`;

export interface PrivateUsersUpdateCompletedArgs {
    userId: string;
}

export async function privateUsersUpdateCompleted(sql: Sql, args: PrivateUsersUpdateCompletedArgs): Promise<void> {
    await sql.unsafe(privateUsersUpdateCompletedQuery, [args.userId]);
}

export const privateUsersUpdateStripeStatusNoneQuery = `-- name: PrivateUsersUpdateStripeStatusNone :exec
update private.users
set stripe_status = 'none'
where user_id = $1`;

export interface PrivateUsersUpdateStripeStatusNoneArgs {
    userId: string;
}

export async function privateUsersUpdateStripeStatusNone(sql: Sql, args: PrivateUsersUpdateStripeStatusNoneArgs): Promise<void> {
    await sql.unsafe(privateUsersUpdateStripeStatusNoneQuery, [args.userId]);
}

export const privateUsersGetRowQuery = `-- name: PrivateUsersGetRow :one
select user_id, stripe_flow_status, stripe_customer_id, stripe_status, stripe_checkout_id, stripe_subscription_id, stripe_price_id, stripe_current_period_end, stripe_current_period_start, stripe_cancel_at_period_end, stripe_payment_method, sub_type from private.users
where user_id = $1`;

export interface PrivateUsersGetRowArgs {
    userId: string;
}

export interface PrivateUsersGetRowRow {
    userId: string;
    stripeFlowStatus: "none" | "initiated" | "completed" | "confirmed";
    stripeCustomerId: string | null;
    stripeStatus: string | null;
    stripeCheckoutId: string | null;
    stripeSubscriptionId: string | null;
    stripePriceId: string | null;
    stripeCurrentPeriodEnd: Date | null;
    stripeCurrentPeriodStart: Date | null;
    stripeCancelAtPeriodEnd: boolean | null;
    stripePaymentMethod: string | null;
    subType: "none" | "stripe" | "code";
}

export async function privateUsersGetRow(sql: Sql, args: PrivateUsersGetRowArgs): Promise<PrivateUsersGetRowRow | null> {
    const rows = await sql.unsafe(privateUsersGetRowQuery, [args.userId]).values();
    if (rows.length !== 1) {
        return null;
    }
    const row = rows[0];
    if (!row) {
        return null;
    }
    return {
        userId: row[0],
        stripeFlowStatus: row[1],
        stripeCustomerId: row[2],
        stripeStatus: row[3],
        stripeCheckoutId: row[4],
        stripeSubscriptionId: row[5],
        stripePriceId: row[6],
        stripeCurrentPeriodEnd: row[7],
        stripeCurrentPeriodStart: row[8],
        stripeCancelAtPeriodEnd: row[9],
        stripePaymentMethod: row[10],
        subType: row[11]
    };
}

export const privateUsersGetRowByStripeCustomerIdQuery = `-- name: PrivateUsersGetRowByStripeCustomerId :one
select user_id, stripe_flow_status, stripe_customer_id, stripe_status, stripe_checkout_id, stripe_subscription_id, stripe_price_id, stripe_current_period_end, stripe_current_period_start, stripe_cancel_at_period_end, stripe_payment_method, sub_type from private.users
where stripe_customer_id = $1`;

export interface PrivateUsersGetRowByStripeCustomerIdArgs {
    stripeCustomerId: string | null;
}

export interface PrivateUsersGetRowByStripeCustomerIdRow {
    userId: string;
    stripeFlowStatus: "none" | "initiated" | "completed" | "confirmed";
    stripeCustomerId: string | null;
    stripeStatus: string | null;
    stripeCheckoutId: string | null;
    stripeSubscriptionId: string | null;
    stripePriceId: string | null;
    stripeCurrentPeriodEnd: Date | null;
    stripeCurrentPeriodStart: Date | null;
    stripeCancelAtPeriodEnd: boolean | null;
    stripePaymentMethod: string | null;
    subType: "none" | "stripe" | "code";
}

export async function privateUsersGetRowByStripeCustomerId(sql: Sql, args: PrivateUsersGetRowByStripeCustomerIdArgs): Promise<PrivateUsersGetRowByStripeCustomerIdRow | null> {
    const rows = await sql.unsafe(privateUsersGetRowByStripeCustomerIdQuery, [args.stripeCustomerId]).values();
    if (rows.length !== 1) {
        return null;
    }
    const row = rows[0];
    if (!row) {
        return null;
    }
    return {
        userId: row[0],
        stripeFlowStatus: row[1],
        stripeCustomerId: row[2],
        stripeStatus: row[3],
        stripeCheckoutId: row[4],
        stripeSubscriptionId: row[5],
        stripePriceId: row[6],
        stripeCurrentPeriodEnd: row[7],
        stripeCurrentPeriodStart: row[8],
        stripeCancelAtPeriodEnd: row[9],
        stripePaymentMethod: row[10],
        subType: row[11]
    };
}

export const planSetRegionQuery = `-- name: PlanSetRegion :exec
update plans
set region = $1
where id = $2`;

export interface PlanSetRegionArgs {
    region: string | null;
    id: string;
}

export async function planSetRegion(sql: Sql, args: PlanSetRegionArgs): Promise<void> {
    await sql.unsafe(planSetRegionQuery, [args.region, args.id]);
}

export const planDeleteQuery = `-- name: PlanDelete :one
update plans
set is_deleted = true
where id = $1
  and user_id = $2
returning id, user_id, created_at, modified_at, start_lat, start_lon, finish_lat, finish_lon, state, name, error, trip_type, distance, bearing, start_desc, finish_desc, rule_set_id, region, is_deleted, map_preview_light, map_preview_dark`;

export interface PlanDeleteArgs {
    id: string;
    userId: string;
}

export interface PlanDeleteRow {
    id: string;
    userId: string;
    createdAt: Date;
    modifiedAt: Date | null;
    startLat: string;
    startLon: string;
    finishLat: string | null;
    finishLon: string | null;
    state: "new" | "planning" | "planning-wider" | "done" | "error";
    name: string;
    error: string | null;
    tripType: "round-trip" | "start-finish";
    distance: string;
    bearing: string | null;
    startDesc: string;
    finishDesc: string | null;
    ruleSetId: string;
    region: string | null;
    isDeleted: boolean;
    mapPreviewLight: string | null;
    mapPreviewDark: string | null;
}

export async function planDelete(sql: Sql, args: PlanDeleteArgs): Promise<PlanDeleteRow | null> {
    const rows = await sql.unsafe(planDeleteQuery, [args.id, args.userId]).values();
    if (rows.length !== 1) {
        return null;
    }
    const row = rows[0];
    if (!row) {
        return null;
    }
    return {
        id: row[0],
        userId: row[1],
        createdAt: row[2],
        modifiedAt: row[3],
        startLat: row[4],
        startLon: row[5],
        finishLat: row[6],
        finishLon: row[7],
        state: row[8],
        name: row[9],
        error: row[10],
        tripType: row[11],
        distance: row[12],
        bearing: row[13],
        startDesc: row[14],
        finishDesc: row[15],
        ruleSetId: row[16],
        region: row[17],
        isDeleted: row[18],
        mapPreviewLight: row[19],
        mapPreviewDark: row[20]
    };
}

export const routeDeleteQuery = `-- name: RouteDelete :one
update routes
set is_deleted = true
where id = $1
  and user_id = $2
returning id, user_id, created_at, plan_id, name, linestring, stats_len_m, stats_score, stats_junction_count, is_deleted, map_preview_light, map_preview_dark`;

export interface RouteDeleteArgs {
    id: string;
    userId: string;
}

export interface RouteDeleteRow {
    id: string;
    userId: string;
    createdAt: Date;
    planId: string;
    name: string;
    linestring: string | null;
    statsLenM: string;
    statsScore: string;
    statsJunctionCount: string;
    isDeleted: boolean;
    mapPreviewLight: string | null;
    mapPreviewDark: string | null;
}

export async function routeDelete(sql: Sql, args: RouteDeleteArgs): Promise<RouteDeleteRow | null> {
    const rows = await sql.unsafe(routeDeleteQuery, [args.id, args.userId]).values();
    if (rows.length !== 1) {
        return null;
    }
    const row = rows[0];
    if (!row) {
        return null;
    }
    return {
        id: row[0],
        userId: row[1],
        createdAt: row[2],
        planId: row[3],
        name: row[4],
        linestring: row[5],
        statsLenM: row[6],
        statsScore: row[7],
        statsJunctionCount: row[8],
        isDeleted: row[9],
        mapPreviewLight: row[10],
        mapPreviewDark: row[11]
    };
}

export const routeDeleteByPlanIdQuery = `-- name: RouteDeleteByPlanId :one
update routes
set is_deleted = true
where plan_id = $1
  and user_id = $2
returning id, user_id, created_at, plan_id, name, linestring, stats_len_m, stats_score, stats_junction_count, is_deleted, map_preview_light, map_preview_dark`;

export interface RouteDeleteByPlanIdArgs {
    planId: string;
    userId: string;
}

export interface RouteDeleteByPlanIdRow {
    id: string;
    userId: string;
    createdAt: Date;
    planId: string;
    name: string;
    linestring: string | null;
    statsLenM: string;
    statsScore: string;
    statsJunctionCount: string;
    isDeleted: boolean;
    mapPreviewLight: string | null;
    mapPreviewDark: string | null;
}

export async function routeDeleteByPlanId(sql: Sql, args: RouteDeleteByPlanIdArgs): Promise<RouteDeleteByPlanIdRow | null> {
    const rows = await sql.unsafe(routeDeleteByPlanIdQuery, [args.planId, args.userId]).values();
    if (rows.length !== 1) {
        return null;
    }
    const row = rows[0];
    if (!row) {
        return null;
    }
    return {
        id: row[0],
        userId: row[1],
        createdAt: row[2],
        planId: row[3],
        name: row[4],
        linestring: row[5],
        statsLenM: row[6],
        statsScore: row[7],
        statsJunctionCount: row[8],
        isDeleted: row[9],
        mapPreviewLight: row[10],
        mapPreviewDark: row[11]
    };
}

export const regionInsertOrUpdateQuery = `-- name: RegionInsertOrUpdate :one
insert into regions (region, geojson, polygon)
values ($1, $2, $3)
on conflict (region) do update
set geojson = excluded.geojson,
  polygon = excluded.polygon
returning region, geojson, polygon`;

export interface RegionInsertOrUpdateArgs {
    region: string;
    geojson: any;
    polygon: string | null;
}

export interface RegionInsertOrUpdateRow {
    region: string;
    geojson: any;
    polygon: string | null;
}

export async function regionInsertOrUpdate(sql: Sql, args: RegionInsertOrUpdateArgs): Promise<RegionInsertOrUpdateRow | null> {
    const rows = await sql.unsafe(regionInsertOrUpdateQuery, [args.region, args.geojson, args.polygon]).values();
    if (rows.length !== 1) {
        return null;
    }
    const row = rows[0];
    if (!row) {
        return null;
    }
    return {
        region: row[0],
        geojson: row[1],
        polygon: row[2]
    };
}

export const ruleSetsListQuery = `-- name: RuleSetsList :many
select id, user_id, name, default_set, is_deleted, icon from rule_sets
where (rule_sets.user_id = $1
  or rule_sets.user_id is null)
  and is_deleted = false
order by default_set desc`;

export interface RuleSetsListArgs {
    userId: string | null;
}

export interface RuleSetsListRow {
    id: string;
    userId: string | null;
    name: string;
    defaultSet: boolean;
    isDeleted: boolean;
    icon: ("touring" | "dualsport" | "adv") | null;
}

export async function ruleSetsList(sql: Sql, args: RuleSetsListArgs): Promise<RuleSetsListRow[]> {
    return (await sql.unsafe(ruleSetsListQuery, [args.userId]).values()).map(row => ({
        id: row[0],
        userId: row[1],
        name: row[2],
        defaultSet: row[3],
        isDeleted: row[4],
        icon: row[5]
    }));
}

export const ruleSetRoadTagsListQuery = `-- name: RuleSetRoadTagsList :many
select user_id, rule_set_id, tag_key, value from rule_set_road_tags
where (rule_set_road_tags.user_id = $1
  or rule_set_road_tags.user_id is null)
  and rule_set_road_tags.rule_set_id in (
    select id from rule_sets
    where (rule_sets.user_id = $1
      or rule_sets.user_id is null)
      and rule_sets.is_deleted = false
  )`;

export interface RuleSetRoadTagsListArgs {
    userId: string | null;
}

export interface RuleSetRoadTagsListRow {
    userId: string | null;
    ruleSetId: string;
    tagKey: string;
    value: number | null;
}

export async function ruleSetRoadTagsList(sql: Sql, args: RuleSetRoadTagsListArgs): Promise<RuleSetRoadTagsListRow[]> {
    return (await sql.unsafe(ruleSetRoadTagsListQuery, [args.userId]).values()).map(row => ({
        userId: row[0],
        ruleSetId: row[1],
        tagKey: row[2],
        value: row[3]
    }));
}

export const ruleSetRoadTagsListByRuleSetIdWithDeletedQuery = `-- name: RuleSetRoadTagsListByRuleSetIdWithDeleted :many
select user_id, rule_set_id, tag_key, value from rule_set_road_tags
where (rule_set_road_tags.user_id = $1
  or rule_set_road_tags.user_id is null)
  and rule_set_road_tags.rule_set_id = $2`;

export interface RuleSetRoadTagsListByRuleSetIdWithDeletedArgs {
    userId: string | null;
    ruleSetId: string;
}

export interface RuleSetRoadTagsListByRuleSetIdWithDeletedRow {
    userId: string | null;
    ruleSetId: string;
    tagKey: string;
    value: number | null;
}

export async function ruleSetRoadTagsListByRuleSetIdWithDeleted(sql: Sql, args: RuleSetRoadTagsListByRuleSetIdWithDeletedArgs): Promise<RuleSetRoadTagsListByRuleSetIdWithDeletedRow[]> {
    return (await sql.unsafe(ruleSetRoadTagsListByRuleSetIdWithDeletedQuery, [args.userId, args.ruleSetId]).values()).map(row => ({
        userId: row[0],
        ruleSetId: row[1],
        tagKey: row[2],
        value: row[3]
    }));
}

export const ruleSetUpsertQuery = `-- name: RuleSetUpsert :one
insert into rule_sets (
  id,
  user_id, 
  name
)
values (
  $1,
  $2,
  $3
)
on conflict (id) do update
set name = excluded.name
returning id, user_id, name, default_set, is_deleted, icon`;

export interface RuleSetUpsertArgs {
    id: string;
    userId: string | null;
    name: string;
}

export interface RuleSetUpsertRow {
    id: string;
    userId: string | null;
    name: string;
    defaultSet: boolean;
    isDeleted: boolean;
    icon: ("touring" | "dualsport" | "adv") | null;
}

export async function ruleSetUpsert(sql: Sql, args: RuleSetUpsertArgs): Promise<RuleSetUpsertRow | null> {
    const rows = await sql.unsafe(ruleSetUpsertQuery, [args.id, args.userId, args.name]).values();
    if (rows.length !== 1) {
        return null;
    }
    const row = rows[0];
    if (!row) {
        return null;
    }
    return {
        id: row[0],
        userId: row[1],
        name: row[2],
        defaultSet: row[3],
        isDeleted: row[4],
        icon: row[5]
    };
}

export const ruleSetRoadTagsUpsertQuery = `-- name: RuleSetRoadTagsUpsert :one
insert into rule_set_road_tags (
  user_id,
  rule_set_id,
  tag_key,
  value
)
values (
  $1,
  $2,
  $3,
  $4
)
on conflict (rule_set_id, tag_key) do update
set value = excluded.value
returning user_id, rule_set_id, tag_key, value`;

export interface RuleSetRoadTagsUpsertArgs {
    userId: string | null;
    ruleSetId: string;
    tagKey: string;
    value: string | null;
}

export interface RuleSetRoadTagsUpsertRow {
    userId: string | null;
    ruleSetId: string;
    tagKey: string;
    value: number | null;
}

export async function ruleSetRoadTagsUpsert(sql: Sql, args: RuleSetRoadTagsUpsertArgs): Promise<RuleSetRoadTagsUpsertRow | null> {
    const rows = await sql.unsafe(ruleSetRoadTagsUpsertQuery, [args.userId, args.ruleSetId, args.tagKey, args.value]).values();
    if (rows.length !== 1) {
        return null;
    }
    const row = rows[0];
    if (!row) {
        return null;
    }
    return {
        userId: row[0],
        ruleSetId: row[1],
        tagKey: row[2],
        value: row[3]
    };
}

export const ruleSetGetQuery = `-- name: RuleSetGet :one
select id, user_id, name, default_set, is_deleted, icon from rule_sets
where rule_sets.id = $1
  and rule_sets.is_deleted = false`;

export interface RuleSetGetArgs {
    id: string;
}

export interface RuleSetGetRow {
    id: string;
    userId: string | null;
    name: string;
    defaultSet: boolean;
    isDeleted: boolean;
    icon: ("touring" | "dualsport" | "adv") | null;
}

export async function ruleSetGet(sql: Sql, args: RuleSetGetArgs): Promise<RuleSetGetRow | null> {
    const rows = await sql.unsafe(ruleSetGetQuery, [args.id]).values();
    if (rows.length !== 1) {
        return null;
    }
    const row = rows[0];
    if (!row) {
        return null;
    }
    return {
        id: row[0],
        userId: row[1],
        name: row[2],
        defaultSet: row[3],
        isDeleted: row[4],
        icon: row[5]
    };
}

export const ruleSetSetDeletedQuery = `-- name: RuleSetSetDeleted :exec
update rule_sets
set is_deleted = true
where id = $1`;

export interface RuleSetSetDeletedArgs {
    id: string;
}

export async function ruleSetSetDeleted(sql: Sql, args: RuleSetSetDeletedArgs): Promise<void> {
    await sql.unsafe(ruleSetSetDeletedQuery, [args.id]);
}

export const routesGetQuery = `-- name: RoutesGet :many
with points_array as (
	select 
		id, 
		array_agg(array[postgis.st_y(p.geom), postgis.st_x(p.geom)] order by p.path) as lat_lon_array
	from routes r, postgis.st_dumppoints(r.linestring) p
	where r.user_id = $1
		and r.id = $2
    and r.is_deleted = false
	group by r.id
) 
select 
	r.id,
	r.name,
	r.created_at,
  r.stats_score,
  r.stats_len_m,
  r.stats_junction_count,
  r.map_preview_light,
  r.map_preview_dark,
	pa.lat_lon_array,
	p.id as plan_id,
	p.name as plan_name,
	p.state as plan_state
from routes r
inner join plans p
	on p.id = r.plan_id 
    and p.is_deleted = false
inner join points_array pa
	on pa.id = r.id
where r.user_id = $1
	and r.id = $2
  and r.is_deleted = false
order by 
	r.created_at desc`;

export interface RoutesGetArgs {
    userId: string;
    id: string;
}

export interface RoutesGetRow {
    id: string;
    name: string;
    createdAt: Date;
    statsScore: string;
    statsLenM: string;
    statsJunctionCount: string;
    mapPreviewLight: string | null;
    mapPreviewDark: string | null;
    latLonArray: string[];
    planId: string;
    planName: string;
    planState: "new" | "planning" | "planning-wider" | "done" | "error";
}

export async function routesGet(sql: Sql, args: RoutesGetArgs): Promise<RoutesGetRow[]> {
    return (await sql.unsafe(routesGetQuery, [args.userId, args.id]).values()).map(row => ({
        id: row[0],
        name: row[1],
        createdAt: row[2],
        statsScore: row[3],
        statsLenM: row[4],
        statsJunctionCount: row[5],
        mapPreviewLight: row[6],
        mapPreviewDark: row[7],
        latLonArray: row[8],
        planId: row[9],
        planName: row[10],
        planState: row[11]
    }));
}

export const routeStatsGetQuery = `-- name: RouteStatsGet :many
select id, user_id, route_id, stat_type, stat_name, len_m, percentage from route_breakdown_stats
where user_id = $1
  and route_id = $2`;

export interface RouteStatsGetArgs {
    userId: string;
    routeId: string;
}

export interface RouteStatsGetRow {
    id: string;
    userId: string;
    routeId: string;
    statType: "type" | "surface" | "smoothness";
    statName: string;
    lenM: string;
    percentage: string;
}

export async function routeStatsGet(sql: Sql, args: RouteStatsGetArgs): Promise<RouteStatsGetRow[]> {
    return (await sql.unsafe(routeStatsGetQuery, [args.userId, args.routeId]).values()).map(row => ({
        id: row[0],
        userId: row[1],
        routeId: row[2],
        statType: row[3],
        statName: row[4],
        lenM: row[5],
        percentage: row[6]
    }));
}

export const planListQuery = `-- name: PlanList :many
select 
	p.id,
	p.name,
	p.start_lat,
	p.start_lon,
  p.start_desc,
	p.finish_lat,
	p.finish_lon,
  p.finish_desc,
  p.distance,
  p.bearing,
  p.trip_type,
	p.state,
	p.created_at,
  p.rule_set_id,
  p.map_preview_light,
  p.map_preview_dark,
	r.id as route_id,
	r.name as route_name,
	r.created_at as route_created_at,
  r.stats_len_m,
  r.map_preview_light as route_map_preview_light,
  r.map_preview_dark as route_map_preview_dark
from plans p
left join routes r 
	on r.plan_id = p.id
  and r.is_deleted = false
where p.user_id = $1
  and p.is_deleted = false
order by
	p.created_at desc,
  r.stats_len_m asc`;

export interface PlanListArgs {
    userId: string;
}

export interface PlanListRow {
    id: string;
    name: string;
    startLat: string;
    startLon: string;
    startDesc: string;
    finishLat: string | null;
    finishLon: string | null;
    finishDesc: string | null;
    distance: string;
    bearing: string | null;
    tripType: "round-trip" | "start-finish";
    state: "new" | "planning" | "planning-wider" | "done" | "error";
    createdAt: Date;
    ruleSetId: string;
    mapPreviewLight: string | null;
    mapPreviewDark: string | null;
    routeId: string | null;
    routeName: string | null;
    routeCreatedAt: Date | null;
    statsLenM: string | null;
    routeMapPreviewLight: string | null;
    routeMapPreviewDark: string | null;
}

export async function planList(sql: Sql, args: PlanListArgs): Promise<PlanListRow[]> {
    return (await sql.unsafe(planListQuery, [args.userId]).values()).map(row => ({
        id: row[0],
        name: row[1],
        startLat: row[2],
        startLon: row[3],
        startDesc: row[4],
        finishLat: row[5],
        finishLon: row[6],
        finishDesc: row[7],
        distance: row[8],
        bearing: row[9],
        tripType: row[10],
        state: row[11],
        createdAt: row[12],
        ruleSetId: row[13],
        mapPreviewLight: row[14],
        mapPreviewDark: row[15],
        routeId: row[16],
        routeName: row[17],
        routeCreatedAt: row[18],
        statsLenM: row[19],
        routeMapPreviewLight: row[20],
        routeMapPreviewDark: row[21]
    }));
}

export const planCreateQuery = `-- name: PlanCreate :one
insert into plans (
  user_id, 
  id, 
  name, 
  start_lat, 
  start_lon, 
  finish_lat, 
  finish_lon, 
  start_desc, 
  finish_desc, 
  trip_type,
  distance,
  bearing,
  rule_set_id
)

values (
  $1, 
  $2, 
  $3, 
  $4, 
  $5, 
  $6, 
  $7, 
  $8, 
  $9, 
  $10,
  $11,
  $12,
  $13
)
returning id`;

export interface PlanCreateArgs {
    userId: string;
    id: string;
    name: string;
    startLat: string;
    startLon: string;
    finishLat: string | null;
    finishLon: string | null;
    startDesc: string;
    finishDesc: string | null;
    tripType: "round-trip" | "start-finish";
    distance: string;
    bearing: string | null;
    ruleSetId: string;
}

export interface PlanCreateRow {
    id: string;
}

export async function planCreate(sql: Sql, args: PlanCreateArgs): Promise<PlanCreateRow | null> {
    const rows = await sql.unsafe(planCreateQuery, [args.userId, args.id, args.name, args.startLat, args.startLon, args.finishLat, args.finishLon, args.startDesc, args.finishDesc, args.tripType, args.distance, args.bearing, args.ruleSetId]).values();
    if (rows.length !== 1) {
        return null;
    }
    const row = rows[0];
    if (!row) {
        return null;
    }
    return {
        id: row[0]
    };
}

export const regionGetQuery = `-- name: RegionGet :many
select region, geojson, polygon from regions`;

export interface RegionGetRow {
    region: string;
    geojson: any;
    polygon: string | null;
}

export async function regionGet(sql: Sql): Promise<RegionGetRow[]> {
    return (await sql.unsafe(regionGetQuery, []).values()).map(row => ({
        region: row[0],
        geojson: row[1],
        polygon: row[2]
    }));
}

export const regionFindFromCoordsQuery = `-- name: RegionFindFromCoords :many
select region, geojson, polygon from public.regions
where postgis.st_within(postgis.st_point($1, $2), regions.polygon)`;

export interface RegionFindFromCoordsArgs {
    lon: string;
    lat: string;
}

export interface RegionFindFromCoordsRow {
    region: string;
    geojson: any;
    polygon: string | null;
}

export async function regionFindFromCoords(sql: Sql, args: RegionFindFromCoordsArgs): Promise<RegionFindFromCoordsRow[]> {
    return (await sql.unsafe(regionFindFromCoordsQuery, [args.lon, args.lat]).values()).map(row => ({
        region: row[0],
        geojson: row[1],
        polygon: row[2]
    }));
}

export const regionGetCountQuery = `-- name: RegionGetCount :one
select count(*) from regions`;

export interface RegionGetCountRow {
    count: string;
}

export async function regionGetCount(sql: Sql): Promise<RegionGetCountRow | null> {
    const rows = await sql.unsafe(regionGetCountQuery, []).values();
    if (rows.length !== 1) {
        return null;
    }
    const row = rows[0];
    if (!row) {
        return null;
    }
    return {
        count: row[0]
    };
}

export const planGetByIdQuery = `-- name: PlanGetById :one
select id, user_id, created_at, modified_at, start_lat, start_lon, finish_lat, finish_lon, state, name, error, trip_type, distance, bearing, start_desc, finish_desc, rule_set_id, region, is_deleted, map_preview_light, map_preview_dark from plans
where plans.id = $1`;

export interface PlanGetByIdArgs {
    id: string;
}

export interface PlanGetByIdRow {
    id: string;
    userId: string;
    createdAt: Date;
    modifiedAt: Date | null;
    startLat: string;
    startLon: string;
    finishLat: string | null;
    finishLon: string | null;
    state: "new" | "planning" | "planning-wider" | "done" | "error";
    name: string;
    error: string | null;
    tripType: "round-trip" | "start-finish";
    distance: string;
    bearing: string | null;
    startDesc: string;
    finishDesc: string | null;
    ruleSetId: string;
    region: string | null;
    isDeleted: boolean;
    mapPreviewLight: string | null;
    mapPreviewDark: string | null;
}

export async function planGetById(sql: Sql, args: PlanGetByIdArgs): Promise<PlanGetByIdRow | null> {
    const rows = await sql.unsafe(planGetByIdQuery, [args.id]).values();
    if (rows.length !== 1) {
        return null;
    }
    const row = rows[0];
    if (!row) {
        return null;
    }
    return {
        id: row[0],
        userId: row[1],
        createdAt: row[2],
        modifiedAt: row[3],
        startLat: row[4],
        startLon: row[5],
        finishLat: row[6],
        finishLon: row[7],
        state: row[8],
        name: row[9],
        error: row[10],
        tripType: row[11],
        distance: row[12],
        bearing: row[13],
        startDesc: row[14],
        finishDesc: row[15],
        ruleSetId: row[16],
        region: row[17],
        isDeleted: row[18],
        mapPreviewLight: row[19],
        mapPreviewDark: row[20]
    };
}

export const plansGetNewQuery = `-- name: PlansGetNew :many
select id, user_id, created_at, modified_at, start_lat, start_lon, finish_lat, finish_lon, state, name, error, trip_type, distance, bearing, start_desc, finish_desc, rule_set_id, region, is_deleted, map_preview_light, map_preview_dark from plans
where state = 'new'`;

export interface PlansGetNewRow {
    id: string;
    userId: string;
    createdAt: Date;
    modifiedAt: Date | null;
    startLat: string;
    startLon: string;
    finishLat: string | null;
    finishLon: string | null;
    state: "new" | "planning" | "planning-wider" | "done" | "error";
    name: string;
    error: string | null;
    tripType: "round-trip" | "start-finish";
    distance: string;
    bearing: string | null;
    startDesc: string;
    finishDesc: string | null;
    ruleSetId: string;
    region: string | null;
    isDeleted: boolean;
    mapPreviewLight: string | null;
    mapPreviewDark: string | null;
}

export async function plansGetNew(sql: Sql): Promise<PlansGetNewRow[]> {
    return (await sql.unsafe(plansGetNewQuery, []).values()).map(row => ({
        id: row[0],
        userId: row[1],
        createdAt: row[2],
        modifiedAt: row[3],
        startLat: row[4],
        startLon: row[5],
        finishLat: row[6],
        finishLon: row[7],
        state: row[8],
        name: row[9],
        error: row[10],
        tripType: row[11],
        distance: row[12],
        bearing: row[13],
        startDesc: row[14],
        finishDesc: row[15],
        ruleSetId: row[16],
        region: row[17],
        isDeleted: row[18],
        mapPreviewLight: row[19],
        mapPreviewDark: row[20]
    }));
}

export const planSetStateQuery = `-- name: PlanSetState :exec
update plans
set 
	state = $1, 
	modified_at = now()
where plans.id = $2`;

export interface PlanSetStateArgs {
    state: "new" | "planning" | "planning-wider" | "done" | "error";
    id: string;
}

export async function planSetState(sql: Sql, args: PlanSetStateArgs): Promise<void> {
    await sql.unsafe(planSetStateQuery, [args.state, args.id]);
}

export const routeInsertQuery = `-- name: RouteInsert :one
insert into routes (
	name, 
	user_id, 
	plan_id, 
  stats_len_m,
  stats_junction_count,
  stats_score,
	linestring
)
values (
	$1, 
	$2, 
	$3, 
  $4,
  $5,
  $6,
	postgis.st_makeline(
		array(
			select 
				postgis.st_point((p->>1)::numeric, (p->>0)::numeric)
			from (
				select jsonb_array_elements($7::jsonb) p
			) arrayPoints
		)
	)
)
returning id, user_id, created_at, plan_id, name, linestring, stats_len_m, stats_score, stats_junction_count, is_deleted, map_preview_light, map_preview_dark`;

export interface RouteInsertArgs {
    name: string;
    userId: string;
    planId: string;
    statsLenM: string;
    statsJunctionCount: string;
    statsScore: string;
    latLonArray: any;
}

export interface RouteInsertRow {
    id: string;
    userId: string;
    createdAt: Date;
    planId: string;
    name: string;
    linestring: string | null;
    statsLenM: string;
    statsScore: string;
    statsJunctionCount: string;
    isDeleted: boolean;
    mapPreviewLight: string | null;
    mapPreviewDark: string | null;
}

export async function routeInsert(sql: Sql, args: RouteInsertArgs): Promise<RouteInsertRow | null> {
    const rows = await sql.unsafe(routeInsertQuery, [args.name, args.userId, args.planId, args.statsLenM, args.statsJunctionCount, args.statsScore, args.latLonArray]).values();
    if (rows.length !== 1) {
        return null;
    }
    const row = rows[0];
    if (!row) {
        return null;
    }
    return {
        id: row[0],
        userId: row[1],
        createdAt: row[2],
        planId: row[3],
        name: row[4],
        linestring: row[5],
        statsLenM: row[6],
        statsScore: row[7],
        statsJunctionCount: row[8],
        isDeleted: row[9],
        mapPreviewLight: row[10],
        mapPreviewDark: row[11]
    };
}

export const routeBreakdownStatsInsertQuery = `-- name: RouteBreakdownStatsInsert :one
insert into route_breakdown_stats (
  user_id,
  route_id,
  stat_type,
  stat_name,
  len_m,
  percentage
)
values (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6
)
returning id, user_id, route_id, stat_type, stat_name, len_m, percentage`;

export interface RouteBreakdownStatsInsertArgs {
    userId: string;
    routeId: string;
    statType: "type" | "surface" | "smoothness";
    statName: string;
    lenM: string;
    percentage: string;
}

export interface RouteBreakdownStatsInsertRow {
    id: string;
    userId: string;
    routeId: string;
    statType: "type" | "surface" | "smoothness";
    statName: string;
    lenM: string;
    percentage: string;
}

export async function routeBreakdownStatsInsert(sql: Sql, args: RouteBreakdownStatsInsertArgs): Promise<RouteBreakdownStatsInsertRow | null> {
    const rows = await sql.unsafe(routeBreakdownStatsInsertQuery, [args.userId, args.routeId, args.statType, args.statName, args.lenM, args.percentage]).values();
    if (rows.length !== 1) {
        return null;
    }
    const row = rows[0];
    if (!row) {
        return null;
    }
    return {
        id: row[0],
        userId: row[1],
        routeId: row[2],
        statType: row[3],
        statName: row[4],
        lenM: row[5],
        percentage: row[6]
    };
}

