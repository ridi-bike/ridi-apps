// Code generated by sqlc. DO NOT EDIT.

import { Sql } from "postgres";

export const regionInsertOrUpdateQuery = `-- name: RegionInsertOrUpdate :one
insert into regions
(region, pbf_md5, version, geojson, polygon)
values
($1, $2, 'next', $3, $4)
on conflict (region, pbf_md5, version) do update
set geojson = excluded.geojson,
	polygon = excluded.polygon
returning id, region, pbf_md5, version, geojson, polygon`;

export interface RegionInsertOrUpdateArgs {
    region: string;
    pbfMd5: string;
    geojson: any;
    polygon: string | null;
}

export interface RegionInsertOrUpdateRow {
    id: string;
    region: string;
    pbfMd5: string;
    version: "previous" | "current" | "next" | "discarded";
    geojson: any;
    polygon: string | null;
}

export async function regionInsertOrUpdate(sql: Sql, args: RegionInsertOrUpdateArgs): Promise<RegionInsertOrUpdateRow | null> {
    const rows = await sql.unsafe(regionInsertOrUpdateQuery, [args.region, args.pbfMd5, args.geojson, args.polygon]).values();
    if (rows.length !== 1) {
        return null;
    }
    const row = rows[0];
    if (!row) {
        return null;
    }
    return {
        id: row[0],
        region: row[1],
        pbfMd5: row[2],
        version: row[3],
        geojson: row[4],
        polygon: row[5]
    };
}

export const regionGetAllCurrentQuery = `-- name: RegionGetAllCurrent :many
select id, region, pbf_md5, version, geojson, polygon from regions
where version = 'current'`;

export interface RegionGetAllCurrentRow {
    id: string;
    region: string;
    pbfMd5: string;
    version: "previous" | "current" | "next" | "discarded";
    geojson: any;
    polygon: string | null;
}

export async function regionGetAllCurrent(sql: Sql): Promise<RegionGetAllCurrentRow[]> {
    return (await sql.unsafe(regionGetAllCurrentQuery, []).values()).map(row => ({
        id: row[0],
        region: row[1],
        pbfMd5: row[2],
        version: row[3],
        geojson: row[4],
        polygon: row[5]
    }));
}

export const regionSetDiscardedQuery = `-- name: RegionSetDiscarded :one
update regions
set version = 'discarded'
where region = $1 and pbf_md5 = $2
returning id, region, pbf_md5, version, geojson, polygon`;

export interface RegionSetDiscardedArgs {
    region: string;
    pbfMd5: string;
}

export interface RegionSetDiscardedRow {
    id: string;
    region: string;
    pbfMd5: string;
    version: "previous" | "current" | "next" | "discarded";
    geojson: any;
    polygon: string | null;
}

export async function regionSetDiscarded(sql: Sql, args: RegionSetDiscardedArgs): Promise<RegionSetDiscardedRow | null> {
    const rows = await sql.unsafe(regionSetDiscardedQuery, [args.region, args.pbfMd5]).values();
    if (rows.length !== 1) {
        return null;
    }
    const row = rows[0];
    if (!row) {
        return null;
    }
    return {
        id: row[0],
        region: row[1],
        pbfMd5: row[2],
        version: row[3],
        geojson: row[4],
        polygon: row[5]
    };
}

export const regionDeleteDiscardedAndPreviousQuery = `-- name: RegionDeleteDiscardedAndPrevious :exec
delete from regions
where region = $1 
	and pbf_md5 = $2 
	and (version = 'discarded' 
		or version = 'previous')`;

export interface RegionDeleteDiscardedAndPreviousArgs {
    region: string;
    pbfMd5: string;
}

export async function regionDeleteDiscardedAndPrevious(sql: Sql, args: RegionDeleteDiscardedAndPreviousArgs): Promise<void> {
    await sql.unsafe(regionDeleteDiscardedAndPreviousQuery, [args.region, args.pbfMd5]);
}

export const regionSetAllPreviousQuery = `-- name: RegionSetAllPrevious :exec
update regions
set version = 'previous'
where regions.version = 'current'`;

export async function regionSetAllPrevious(sql: Sql): Promise<void> {
    await sql.unsafe(regionSetAllPreviousQuery, []);
}

export const regionSetCurrentQuery = `-- name: RegionSetCurrent :exec
update regions
set version = 'current'
where regions.region = $1
	and regions.pbf_md5 = $2`;

export interface RegionSetCurrentArgs {
    region: string;
    pbfMd5: string;
}

export async function regionSetCurrent(sql: Sql, args: RegionSetCurrentArgs): Promise<void> {
    await sql.unsafe(regionSetCurrentQuery, [args.region, args.pbfMd5]);
}

export const regionFindFromCoordsQuery = `-- name: RegionFindFromCoords :many
select id, region, pbf_md5, version, geojson, polygon from public.regions
where version = 'current'
	and postgis.st_within(postgis.st_point($1, $2), regions.polygon)`;

export interface RegionFindFromCoordsArgs {
    lon: string;
    lat: string;
}

export interface RegionFindFromCoordsRow {
    id: string;
    region: string;
    pbfMd5: string;
    version: "previous" | "current" | "next" | "discarded";
    geojson: any;
    polygon: string | null;
}

export async function regionFindFromCoords(sql: Sql, args: RegionFindFromCoordsArgs): Promise<RegionFindFromCoordsRow[]> {
    return (await sql.unsafe(regionFindFromCoordsQuery, [args.lon, args.lat]).values()).map(row => ({
        id: row[0],
        region: row[1],
        pbfMd5: row[2],
        version: row[3],
        geojson: row[4],
        polygon: row[5]
    }));
}

export const regionGetCountQuery = `-- name: RegionGetCount :one
select count(*) from regions`;

export interface RegionGetCountRow {
    count: string;
}

export async function regionGetCount(sql: Sql): Promise<RegionGetCountRow | null> {
    const rows = await sql.unsafe(regionGetCountQuery, []).values();
    if (rows.length !== 1) {
        return null;
    }
    const row = rows[0];
    if (!row) {
        return null;
    }
    return {
        count: row[0]
    };
}

export const planGetByIdQuery = `-- name: PlanGetById :one
select id, user_id, created_at, modified_at, from_lat, from_lon, to_lat, to_lon, state, name, error from plans
where plans.id = $1`;

export interface PlanGetByIdArgs {
    id: string;
}

export interface PlanGetByIdRow {
    id: string;
    userId: string;
    createdAt: Date;
    modifiedAt: Date | null;
    fromLat: string;
    fromLon: string;
    toLat: string;
    toLon: string;
    state: "new" | "planning" | "done" | "error";
    name: string;
    error: string | null;
}

export async function planGetById(sql: Sql, args: PlanGetByIdArgs): Promise<PlanGetByIdRow | null> {
    const rows = await sql.unsafe(planGetByIdQuery, [args.id]).values();
    if (rows.length !== 1) {
        return null;
    }
    const row = rows[0];
    if (!row) {
        return null;
    }
    return {
        id: row[0],
        userId: row[1],
        createdAt: row[2],
        modifiedAt: row[3],
        fromLat: row[4],
        fromLon: row[5],
        toLat: row[6],
        toLon: row[7],
        state: row[8],
        name: row[9],
        error: row[10]
    };
}

export const plansGetNewQuery = `-- name: PlansGetNew :many
select id, user_id, created_at, modified_at, from_lat, from_lon, to_lat, to_lon, state, name, error from plans
where state = 'new'`;

export interface PlansGetNewRow {
    id: string;
    userId: string;
    createdAt: Date;
    modifiedAt: Date | null;
    fromLat: string;
    fromLon: string;
    toLat: string;
    toLon: string;
    state: "new" | "planning" | "done" | "error";
    name: string;
    error: string | null;
}

export async function plansGetNew(sql: Sql): Promise<PlansGetNewRow[]> {
    return (await sql.unsafe(plansGetNewQuery, []).values()).map(row => ({
        id: row[0],
        userId: row[1],
        createdAt: row[2],
        modifiedAt: row[3],
        fromLat: row[4],
        fromLon: row[5],
        toLat: row[6],
        toLon: row[7],
        state: row[8],
        name: row[9],
        error: row[10]
    }));
}

export const planSetStateQuery = `-- name: PlanSetState :exec
update plans
set 
	state = $1, 
	modified_at = now()
where plans.id = $2`;

export interface PlanSetStateArgs {
    state: "new" | "planning" | "done" | "error";
    id: string;
}

export async function planSetState(sql: Sql, args: PlanSetStateArgs): Promise<void> {
    await sql.unsafe(planSetStateQuery, [args.state, args.id]);
}

export const routeInsertQuery = `-- name: RouteInsert :one
insert into routes (
	name, 
	user_id, 
	plan_id, 
	linestring
)
values (
	$1, 
	$2, 
	$3, 
	postgis.st_makeline(
		array(
			select 
				postgis.st_point((p->>1)::numeric, (p->>0)::numeric)
			from (
				select jsonb_array_elements($4::jsonb) p
			) arrayPoints
		)
	)
)
returning id, user_id, created_at, plan_id, name, linestring`;

export interface RouteInsertArgs {
    name: string;
    userId: string;
    planId: string;
    latLonArray: any;
}

export interface RouteInsertRow {
    id: string;
    userId: string;
    createdAt: Date;
    planId: string;
    name: string;
    linestring: string | null;
}

export async function routeInsert(sql: Sql, args: RouteInsertArgs): Promise<RouteInsertRow | null> {
    const rows = await sql.unsafe(routeInsertQuery, [args.name, args.userId, args.planId, args.latLonArray]).values();
    if (rows.length !== 1) {
        return null;
    }
    const row = rows[0];
    if (!row) {
        return null;
    }
    return {
        id: row[0],
        userId: row[1],
        createdAt: row[2],
        planId: row[3],
        name: row[4],
        linestring: row[5]
    };
}

