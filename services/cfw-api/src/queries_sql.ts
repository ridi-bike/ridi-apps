// Code generated by sqlc. DO NOT EDIT.

import { Sql } from "postgres";

export const ruleSetsListQuery = `-- name: RuleSetsList :many
select id, user_id, name from rule_sets
where rule_sets.user_id = $1
  or rule_sets.user_id is null`;

export interface RuleSetsListArgs {
    userId: string | null;
}

export interface RuleSetsListRow {
    id: string;
    userId: string | null;
    name: string;
}

export async function ruleSetsList(sql: Sql, args: RuleSetsListArgs): Promise<RuleSetsListRow[]> {
    return (await sql.unsafe(ruleSetsListQuery, [args.userId]).values()).map(row => ({
        id: row[0],
        userId: row[1],
        name: row[2]
    }));
}

export const ruleSetRoadTagsGetQuery = `-- name: RuleSetRoadTagsGet :many
select user_id, rule_set_id, tag_key, value from rule_set_road_tags
where rule_set_road_tags.user_id = $1
  or rule_set_road_tags.user_id is null`;

export interface RuleSetRoadTagsGetArgs {
    userId: string | null;
}

export interface RuleSetRoadTagsGetRow {
    userId: string | null;
    ruleSetId: string;
    tagKey: string;
    value: number | null;
}

export async function ruleSetRoadTagsGet(sql: Sql, args: RuleSetRoadTagsGetArgs): Promise<RuleSetRoadTagsGetRow[]> {
    return (await sql.unsafe(ruleSetRoadTagsGetQuery, [args.userId]).values()).map(row => ({
        userId: row[0],
        ruleSetId: row[1],
        tagKey: row[2],
        value: row[3]
    }));
}

export const ruleSetUpsertQuery = `-- name: RuleSetUpsert :one
insert into rule_sets (
  id,
  user_id, 
  name
)
values (
  $1,
  $2,
  $3
)
on conflict (id) do update
set name = excluded.name
returning id, user_id, name`;

export interface RuleSetUpsertArgs {
    id: string;
    userId: string | null;
    name: string;
}

export interface RuleSetUpsertRow {
    id: string;
    userId: string | null;
    name: string;
}

export async function ruleSetUpsert(sql: Sql, args: RuleSetUpsertArgs): Promise<RuleSetUpsertRow | null> {
    const rows = await sql.unsafe(ruleSetUpsertQuery, [args.id, args.userId, args.name]).values();
    if (rows.length !== 1) {
        return null;
    }
    const row = rows[0];
    if (!row) {
        return null;
    }
    return {
        id: row[0],
        userId: row[1],
        name: row[2]
    };
}

export const ruleSetRoadTagsUpsertQuery = `-- name: RuleSetRoadTagsUpsert :one
insert into rule_set_road_tags (
  user_id,
  rule_set_id,
  tag_key,
  value
)
values (
  $1,
  $2,
  $3,
  $4
)
on conflict (rule_set_id, tag_key) do update
set value = excluded.value
returning user_id, rule_set_id, tag_key, value`;

export interface RuleSetRoadTagsUpsertArgs {
    userId: string | null;
    ruleSetId: string;
    tagKey: string;
    value: string | null;
}

export interface RuleSetRoadTagsUpsertRow {
    userId: string | null;
    ruleSetId: string;
    tagKey: string;
    value: number | null;
}

export async function ruleSetRoadTagsUpsert(sql: Sql, args: RuleSetRoadTagsUpsertArgs): Promise<RuleSetRoadTagsUpsertRow | null> {
    const rows = await sql.unsafe(ruleSetRoadTagsUpsertQuery, [args.userId, args.ruleSetId, args.tagKey, args.value]).values();
    if (rows.length !== 1) {
        return null;
    }
    const row = rows[0];
    if (!row) {
        return null;
    }
    return {
        userId: row[0],
        ruleSetId: row[1],
        tagKey: row[2],
        value: row[3]
    };
}

export const ruleSetGetQuery = `-- name: RuleSetGet :one
select id, user_id, name from rule_sets
where rule_sets.id = $1`;

export interface RuleSetGetArgs {
    id: string;
}

export interface RuleSetGetRow {
    id: string;
    userId: string | null;
    name: string;
}

export async function ruleSetGet(sql: Sql, args: RuleSetGetArgs): Promise<RuleSetGetRow | null> {
    const rows = await sql.unsafe(ruleSetGetQuery, [args.id]).values();
    if (rows.length !== 1) {
        return null;
    }
    const row = rows[0];
    if (!row) {
        return null;
    }
    return {
        id: row[0],
        userId: row[1],
        name: row[2]
    };
}

export const ruleSetDeleteQuery = `-- name: RuleSetDelete :exec
delete from rule_sets
where id = $1`;

export interface RuleSetDeleteArgs {
    id: string;
}

export async function ruleSetDelete(sql: Sql, args: RuleSetDeleteArgs): Promise<void> {
    await sql.unsafe(ruleSetDeleteQuery, [args.id]);
}

export const routesGetQuery = `-- name: RoutesGet :many
with points_array as (
	select 
		id, 
		array_agg(array[postgis.st_y(p.geom), postgis.st_x(p.geom)] order by p.path) as lat_lon_array
	from routes r, postgis.st_dumppoints(r.linestring) p
	where r.user_id = $1
		and r.id = $2
	group by r.id
) 
select 
	r.id,
	r.name,
	r.created_at,
  r.stats_score,
  r.stats_len_m,
  r.stats_junction_count,
	pa.lat_lon_array,
	p.id as plan_id,
	p.name as plan_name,
	p.state as plan_state
from routes r
inner join plans p
	on p.id = r.plan_id
inner join points_array pa
	on pa.id = r.id
where r.user_id = $1
	and r.id = $2
order by 
	r.created_at desc`;

export interface RoutesGetArgs {
    userId: string;
    id: string;
}

export interface RoutesGetRow {
    id: string;
    name: string;
    createdAt: Date;
    statsScore: string;
    statsLenM: string;
    statsJunctionCount: string;
    latLonArray: string[];
    planId: string;
    planName: string;
    planState: "new" | "planning" | "done" | "error";
}

export async function routesGet(sql: Sql, args: RoutesGetArgs): Promise<RoutesGetRow[]> {
    return (await sql.unsafe(routesGetQuery, [args.userId, args.id]).values()).map(row => ({
        id: row[0],
        name: row[1],
        createdAt: row[2],
        statsScore: row[3],
        statsLenM: row[4],
        statsJunctionCount: row[5],
        latLonArray: row[6],
        planId: row[7],
        planName: row[8],
        planState: row[9]
    }));
}

export const routeStatsGetQuery = `-- name: RouteStatsGet :many
select id, user_id, route_id, stat_type, stat_name, len_m, percentage from route_breakdown_stats
where user_id = $1
  and route_id = $2`;

export interface RouteStatsGetArgs {
    userId: string;
    routeId: string;
}

export interface RouteStatsGetRow {
    id: string;
    userId: string;
    routeId: string;
    statType: "type" | "surface" | "smoothness";
    statName: string;
    lenM: string;
    percentage: string;
}

export async function routeStatsGet(sql: Sql, args: RouteStatsGetArgs): Promise<RouteStatsGetRow[]> {
    return (await sql.unsafe(routeStatsGetQuery, [args.userId, args.routeId]).values()).map(row => ({
        id: row[0],
        userId: row[1],
        routeId: row[2],
        statType: row[3],
        statName: row[4],
        lenM: row[5],
        percentage: row[6]
    }));
}

export const planListQuery = `-- name: PlanList :many
select 
	p.id,
	p.name,
	p.start_lat,
	p.start_lon,
  p.start_desc,
	p.finish_lat,
	p.finish_lon,
  p.finish_desc,
  p.distance,
  p.bearing,
  p.trip_type,
	p.state,
	p.created_at,
  p.rule_set_id,
	r.id as route_id,
	r.name as route_name,
	r.created_at as route_created_at
from plans p
left join routes r 
	on r.plan_id = p.id
where p.user_id = $1
order by
	p.created_at desc`;

export interface PlanListArgs {
    userId: string;
}

export interface PlanListRow {
    id: string;
    name: string;
    startLat: string;
    startLon: string;
    startDesc: string;
    finishLat: string | null;
    finishLon: string | null;
    finishDesc: string | null;
    distance: string;
    bearing: string | null;
    tripType: "round-trip" | "start-finish";
    state: "new" | "planning" | "done" | "error";
    createdAt: Date;
    ruleSetId: string;
    routeId: string | null;
    routeName: string | null;
    routeCreatedAt: Date | null;
}

export async function planList(sql: Sql, args: PlanListArgs): Promise<PlanListRow[]> {
    return (await sql.unsafe(planListQuery, [args.userId]).values()).map(row => ({
        id: row[0],
        name: row[1],
        startLat: row[2],
        startLon: row[3],
        startDesc: row[4],
        finishLat: row[5],
        finishLon: row[6],
        finishDesc: row[7],
        distance: row[8],
        bearing: row[9],
        tripType: row[10],
        state: row[11],
        createdAt: row[12],
        ruleSetId: row[13],
        routeId: row[14],
        routeName: row[15],
        routeCreatedAt: row[16]
    }));
}

export const planCreateQuery = `-- name: PlanCreate :one
insert into plans (
  user_id, 
  id, 
  name, 
  start_lat, 
  start_lon, 
  finish_lat, 
  finish_lon, 
  start_desc, 
  finish_desc, 
  trip_type,
  distance,
  bearing,
  rule_set_id
)

values (
  $1, 
  $2, 
  $3, 
  $4, 
  $5, 
  $6, 
  $7, 
  $8, 
  $9, 
  $10,
  $11,
  $12,
  $13
)
returning id`;

export interface PlanCreateArgs {
    userId: string;
    id: string;
    name: string;
    startLat: string;
    startLon: string;
    finishLat: string | null;
    finishLon: string | null;
    startDesc: string;
    finishDesc: string | null;
    tripType: "round-trip" | "start-finish";
    distance: string;
    bearing: string | null;
    ruleSetId: string;
}

export interface PlanCreateRow {
    id: string;
}

export async function planCreate(sql: Sql, args: PlanCreateArgs): Promise<PlanCreateRow | null> {
    const rows = await sql.unsafe(planCreateQuery, [args.userId, args.id, args.name, args.startLat, args.startLon, args.finishLat, args.finishLon, args.startDesc, args.finishDesc, args.tripType, args.distance, args.bearing, args.ruleSetId]).values();
    if (rows.length !== 1) {
        return null;
    }
    const row = rows[0];
    if (!row) {
        return null;
    }
    return {
        id: row[0]
    };
}

